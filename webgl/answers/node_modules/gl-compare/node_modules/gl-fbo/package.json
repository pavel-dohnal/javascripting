{
  "name": "gl-fbo",
  "version": "1.1.3",
  "description": "Frame buffer object wrapper for WebGL",
  "main": "fbo.js",
  "dependencies": {
    "webglew": "^1.0.0",
    "gl-texture2d": "^1.1.0"
  },
  "devDependencies": {
    "gl-now": "^1.3.1",
    "ndarray": "^1.0.15",
    "ndarray-fill": "^1.0.1",
    "glslify": "^1.4.0",
    "a-big-triangle": "0.0.0"
  },
  "scripts": {
    "test": "tap test/*.js",
    "start": "beefy --open example/example.js -- --transform glslify"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/fbo.git"
  },
  "keywords": [
    "fbo",
    "frame",
    "buffer",
    "framebuffer",
    "object",
    "webgl",
    "gl",
    "offscreen",
    "render",
    "texture",
    "renderbuffer",
    "render"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "6173b4ee305e99f359a1a5939bba28169699d9ef",
  "readme": "gl-fbo\n======\nWebGL framebuffer object wrapper\n\n## Example\n\n[Try this in your browser if you have WebGL](http://gl-modules.github.io/gl-fbo/)\n\n```javascript\nvar shell = require(\"gl-now\")()\nvar createFBO = require(\"gl-fbo\")\nvar glslify = require(\"glslify\")\nvar ndarray = require(\"ndarray\")\nvar fill = require(\"ndarray-fill\")\nvar fillScreen = require(\"a-big-triangle\")\n\nvar createUpdateShader = glslify({\n  vertex: \"\\\n    attribute vec2 position;\\\n    varying vec2 uv;\\\n    void main() {\\\n      gl_Position = vec4(position,0.0,1.0);\\\n      uv = 0.5 * (position+1.0);\\\n    }\",\n  fragment: \"\\\n    precision mediump float;\\\n    uniform sampler2D buffer;\\\n    uniform vec2 dims;\\\n    varying vec2 uv;\\\n    void main() {\\\n      float n = 0.0;\\\n      for(int dx=-1; dx<=1; ++dx)\\\n      for(int dy=-1; dy<=1; ++dy) {\\\n        n += texture2D(buffer, uv+vec2(dx,dy)/dims).r;\\\n      }\\\n      float s = texture2D(buffer, uv).r;\\\n      if(n > 3.0+s || n < 3.0) {\\\n        gl_FragColor = vec4(0,0,0,1);\\\n      } else {\\\n        gl_FragColor = vec4(1,1,1,1);\\\n      }\\\n    }\",\n  inline: true\n})\n\nvar createDrawShader = glslify({\n  vertex: \"\\\n    attribute vec2 position;\\\n    varying vec2 uv;\\\n    void main() {\\\n      gl_Position = vec4(position,0.0,1.0);\\\n      uv = 0.5 * (position+1.0);\\\n    }\",\n  fragment: \"\\\n    precision mediump float;\\\n    uniform sampler2D buffer;\\\n    varying vec2 uv;\\\n    void main() {\\\n      gl_FragColor = texture2D(buffer, uv);\\\n    }\",\n  inline: true\n})\n\nvar state, updateShader, drawShader, current = 0\n\nshell.on(\"gl-init\", function() {\n  var gl = shell.gl\n  \n  //Turn off depth test\n  gl.disable(gl.DEPTH_TEST)\n\n  //Initialize shaders\n  updateShader = createUpdateShader(gl)\n  drawShader = createDrawShader(gl)\n\n  //Allocate buffers\n  state = [ createFBO(gl, [512, 512]), createFBO(gl, [512, 512]) ]\n  \n  //Initialize state buffer\n  var initial_conditions = ndarray(new Uint8Array(512*512*4), [512, 512, 4])\n  fill(initial_conditions, function(x,y,c) {\n    if(c === 3) {\n      return 255\n    }\n    return Math.random() > 0.9 ? 255 : 0\n  })\n  state[0].color[0].setPixels(initial_conditions)\n  \n  //Set up vertex pointers\n  drawShader.attributes.position.location = updateShader.attributes.position.location = 0\n})\n\nshell.on(\"tick\", function() {\n  var gl = shell.gl\n  var prevState = state[current]\n  var curState = state[current ^= 1]\n\n  //Switch to state fbo\n  curState.bind()\n  \n  //Run update shader\n  updateShader.bind()\n  updateShader.uniforms.buffer = prevState.color[0].bind()\n  updateShader.uniforms.dims = prevState.shape\n  fillScreen(gl)\n})\n\nshell.on(\"gl-render\", function(t) {\n  var gl = shell.gl\n  \n  //Render contents of buffer to screen\n  drawShader.bind()\n  drawShader.uniforms.buffer = state[current].color[0].bind()\n  fillScreen(gl)\n})\n```\n\nResult:\n\n<img src=\"https://raw.github.com/mikolalysenko/gl-fbo/master/screenshot.png\">\n\n\n## Install\n\nInstall using npm:\n\n    npm install gl-fbo\n\n# API\n\n### `var createFBO = require(\"gl-fbo\")`\n\n## Constructor\nThere is currently only one default way to create a Framebuffer object.  You can construct a framebuffer using the following syntax:\n\n### `var fbo = createFBO(gl, shape[, options])`\nCreates a wrapped framebuffer object\n\n* `gl` is a handle to a WebGL context\n* `shape` is a length 2 array encoding the `[rows, columns]` of the frame buffer\n* `options` is an object containing the following optional properties:\n\n    + `options.float` Use floating point textures (default `false`)\n    + `options.preferFloat` Upgrade to floating point if available, otherwise fallback to 8bit. (default `false`)\n    + `options.color`  The number of color buffers to create (default `1`)\n    + `options.depth` If fbo has a depth buffer (default: `true`)\n    + `options.stencil` If fbo has a stencil buffer (default: `false`)\n\n## Methods\n\n### `fbo.bind()`\nBinds the framebuffer object to the display.\n\n### `fbo.dispose()`\nDestroys the framebuffer object and releases all associated resources\n\n## Properties\n\n\n### `fbo.shape`\nReturns the shape of the frame buffer object.  Writing to this property resizes the framebuffer.  For example,\n\n```javascript\nfbo.shape = [ numRows, numCols ]\n```\n\n### `fbo.gl`\nA reference to the WebGL context\n\n### `fbo.handle`\nA handle to the underlying Framebuffer object.\n\n### `fbo.color`\nAn containing [`gl-texture2d`](https://github.com/mikolalysenko/gl-texture2d) objects representing the buffers.  \n\n### `fbo.depth`\nThe depth/stencil component of the FBO.  Stored as a [`gl-texture2d`](https://github.com/mikolalysenko/gl-texture2d).  If not present, is null.\n\n\nCredits\n=======\n(c) 2013-2014 Mikola Lysenko. MIT",
  "bugs": {
    "url": "https://github.com/mikolalysenko/fbo/issues"
  },
  "homepage": "https://github.com/mikolalysenko/fbo",
  "_id": "gl-fbo@1.1.3",
  "_from": "gl-fbo@^1.1.0"
}
