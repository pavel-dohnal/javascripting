{
  "name": "glslify",
  "version": "1.6.0",
  "description": "command line glsl module system builder",
  "main": "index.js",
  "scripts": {
    "test": "node test/index.js"
  },
  "bin": {
    "glslify": "./bin/glslify"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gl-modules/glslify.git"
  },
  "keywords": [
    "glslify",
    "glsl",
    "module",
    "system",
    "cli"
  ],
  "authors": [
    "Hugh Kennedy <hughskennedy@gmail.com> (http://hughsk.io/)",
    "Mikola Lysenko <mikolalysenko@gmail.com> (http://0fps.net)",
    "Chris Dickinson <chris@neversaw.us> (http://neversaw.us)"
  ],
  "license": "MIT",
  "preferGlobal": "true",
  "dependencies": {
    "concat-stream": "^1.4.1",
    "cssauron": "0.0.2",
    "cssauron-glsl": "0.0.0",
    "emit-function": "0.0.2",
    "esprima": "^1.0.4",
    "gl-shader-core": "^2.0.0",
    "glsl-deparser": "0.0.2",
    "glsl-extract": "0.0.2",
    "glsl-min-stream": "0.0.2",
    "glslify-stream": "^0.4.0",
    "new-from": "^0.0.3",
    "nopt": "^2.0.0",
    "replace-method": "0.0.0",
    "resolve": "^0.6.1",
    "shortest": "0.0.0",
    "sleuth": "0.0.0",
    "static-eval": "^0.2.2",
    "through": "^2.3.4"
  },
  "browser": {
    "index.js": "browser.js"
  },
  "readme": "# glslify\n\na module system for GLSL and a transform enabling easy access to GLSL Shaders in JavaScript.\n\n## As a Browserify transform:\n\n```bash\n$ npm install --save glslify\n$ browserify entry.js -t glslify > bundle.js\n```\n\nglslify will find and replace all instances of `glslify({vertex: path, fragment: path})`\nwith a function that takes a webgl context and returns a [shader instance](http://npm.im/gl-shader-core).\n\nRecommended usage:\n\n```javascript\nvar glslify = require('glslify')    // requiring `glslify` is safe in this context.\n                                    // if the program is run without the transform,\n                                    // it'll output a helpful error message.\nvar shell = require('gl-now')()\n\nvar createShader = glslify({\n    vertex: './vertex.glsl'\n  , fragment: './fragment.glsl'\n})\n\nvar program\n\nshell.on('gl-init', function() {\n  program = createShader(shell.gl)\n})\n```\n\nAs part of the transform, the program will be analyzed for its **uniforms** and **attributes**,\nso once you have a `program` instance, the following will work:\n\n```javascript\n\n// given a glsl program containing:\n//\n//   uniform vec2 color;\n//   uniform mat4 view;\n\nprogram.bind()\nprogram.uniforms.color = [0.5, 1.0]\nprogram.uniforms.view = [\n  1, 0, 0, 0\n, 0, 1, 0, 0\n, 0, 0, 1, 0\n, 0, 0, 0, 1\n]\n\n```\n\nThe following options may be passed into glslify's transformed constructor:\n\n* `fragment`: the fragment shader to use.\n* `vertex`: the vertex shader to use.\n* `inline`: instead of loading the vertex/fragment shaders from a file path,\n  use the string values of these options directly to generate the shaders.\n* `transform`: a string or array of strings naming browserify-transform stream\n  modules you would like to use to transform these shaders.\n\n## As a GLSL module system:\n\nglslify can be run as a standalone command as well:\n\n\n```bash\n$ glslify my-module.glsl > output.glsl\n```\n\nglslify allows you to write GLSL modules that export a local function, variable, or type,\nand `require` those modules to bring that export into another module.\n\nLookups work like node's `require` -- that is, it'll work relatively to the file first,\nand then work from the file's directory on up to the root directory looking for a package\nin `node_modules/`.\n\n## example files\n\n| [`main.glsl`](#mainglsl) | [`file1.glsl`](#file1glsl) | [`file2.glsl`](#file2glsl) |\n|---------------------------|-----------------------------|-----------------------------|\n\n### main.glsl\n\n[back to file list](#example-files)\n\n```c\n// main.glsl\nprecision highp float;\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// require a function from another file!\n#pragma glslify: program_one = require(./file1)\n\n// require a function from another file, and replace\n// `local_value` in that file with `resolution.x` from\n// this scope.\n#pragma glslify: program_two = require(./file2, local_value=resolution.x)\n\nint modulo(float x, float y) {\n  return int(x - y * floor(x / y));\n}\n\nvoid main(void) {\n  ivec2 m = ivec2(modulo(gl_FragCoord.x, 2.), modulo(gl_FragCoord.y, 2.));\n\n  if(m.x == 0 || m.y == 0) {\n    program_one();\n  } else { \n    program_two();\n  }\n}\n```\n\n\n### file1.glsl\n\n[back to file list](#example-files)\n\n```c\n// file1.glsl\nvoid main(void) {\n  gl_FragColor = vec4(1., 0., 0., 1.);\n}\n\n#pragma glslify: export(main)\n```\n\n### file2.glsl\n\n[back to file list](#example-files)\n\n```c\n// file2.glsl\n\nuniform float local_value;\n\nvoid main(void) {\n  gl_FragColor = vec4(0., 0., local_value, 1.);\n}\n\n#pragma glslify: export(main)\n```\n# GLSL API\n\nGLSLify works by mangling top-level identities in non-root modules.\n\nExported variables will be aliased on requirement.\n\n### \\#pragma glslify: VARIABLE = require(MODULE[, NAME=EXPR])\n\nImport a module and assign it the name `VARIABLE` in the local program.\n\n`MODULE` may be located within `node_modules/` or relative to the current file.\n\n**Quotes are not allowed.**\n\nIf the target module defines `attribute`, `varying`, or `uniform` global variables,\nyou may map those to a local definition or expression:\n\n```c\n\nattribute vec4 position;\n#pragma glslify: x = require(./takes_vec2, module_variable=position.xy)\n\n```\n\nIf a mapping is not defined, those requirements are forwarded on to the module requiring\nthe current module -- if no mappings are found for a definition, an error is raised.\n\n### \\#pragma glslify: export(NAME)\n\nExports a local name from the current module. If the current module is the root, this is\na no-op. There may be only one exported `NAME` per module. The `NAME` may represent a\ntype, function, or variable.\n\n\n# With ThreeJS\n\nYou can use the `sourceOnly` option to integrate glslfiy with ThreeJS and other WebGL frameworks. This will return an object with `vertex` and `fragment` shader source, which you can then compile yourself.\n\nIn ThreeJS it might look like this:  \n\n```js\nvar myShader = glslify({\n    vertex: './vertex.glsl',\n    fragment: './fragment.glsl',\n    sourceOnly: true\n});\n\n//optionally do something with our uniforms/attribs\nconsole.log( myShader.uniforms, myShader.attributes );\n\n//setup custom ThreeJS material...\nvar mat = new THREE.ShaderMaterial({\n    vertexShader: myShader.vertex,\n    fragmentShader: myShader.fragment\n    uniforms: { \n      // setup your uniforms..\n    }\n});\n\n```\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/gl-modules/glslify/issues"
  },
  "homepage": "https://github.com/gl-modules/glslify",
  "_id": "glslify@1.6.0",
  "_from": "glslify@^1.6.0"
}
